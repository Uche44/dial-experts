{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/base-x/src/index.js"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/bs58/index.js"],"sourcesContent":["var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n"],"names":[],"mappings":"AAAA,IAAI;AACJ,IAAI,WAAW;AAEf,OAAO,OAAO,GAAG,MAAM","ignoreList":[0]}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout/lib/Layout.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout/src/Layout.ts"],"sourcesContent":["unable to read source [project]/node_modules/@solana/buffer-layout/src/Layout.ts"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2309, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/bytes.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/combine-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/assertions.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/offset-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/resize-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/pad-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/reverse-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 2910, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/dist/index.browser.mjs","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/bytes.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/combine-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/assertions.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/offset-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/resize-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/pad-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/reverse-codec.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"names":["SolanaError"],"mappings":"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"}},
    {"offset": {"line": 3511, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/assertions.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/common.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/utils.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/f32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/f64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i128.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/i8.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/short-u16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u128.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/web3.js/node_modules/%40solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"names":["Endian","combineCodec","createEncoder","createDecoder"],"mappings":"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"}},
    {"offset": {"line": 3924, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/dist/index.browser.mjs","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/assertions.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/common.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/utils.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/f32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/f64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/i128.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/i16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/i32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/i64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/i8.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/short-u16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/u128.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/u16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/u32.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/u64.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"names":["Endian","combineCodec","createEncoder","createDecoder"],"mappings":"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"}},
    {"offset": {"line": 4337, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-adapter-base/src/transaction.ts"],"sourcesContent":["import type { Transaction, TransactionVersion, VersionedTransaction } from '@solana/web3.js';\n\nexport type SupportedTransactionVersions = ReadonlySet<TransactionVersion> | null | undefined;\n\nexport type TransactionOrVersionedTransaction<S extends SupportedTransactionVersions> = S extends null | undefined\n    ? Transaction\n    : Transaction | VersionedTransaction;\n\nexport function isVersionedTransaction(\n    transaction: Transaction | VersionedTransaction\n): transaction is VersionedTransaction {\n    return 'version' in transaction;\n}\n"],"names":[],"mappings":";;;;AAQM,SAAU,sBAAsB,CAClC,WAA+C;IAE/C,OAAO,SAAS,IAAI,WAAW,CAAC;AACpC,CAAC"}},
    {"offset": {"line": 4348, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-adapter-base/lib/esm/standard.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-adapter-base/src/standard.ts"],"sourcesContent":["import {\n    SolanaSignAndSendTransaction,\n    type SolanaSignAndSendTransactionFeature,\n    type SolanaSignInFeature,\n    type SolanaSignMessageFeature,\n    SolanaSignTransaction,\n    type SolanaSignTransactionFeature,\n} from '@solana/wallet-standard-features';\nimport type { Wallet as StandardWallet, WalletWithFeatures as StandardWalletWithFeatures } from '@wallet-standard/base';\nimport {\n    StandardConnect,\n    type StandardConnectFeature,\n    type StandardDisconnectFeature,\n    StandardEvents,\n    type StandardEventsFeature,\n} from '@wallet-standard/features';\nimport type { WalletAdapter, WalletAdapterProps } from './adapter.js';\n\nexport type WalletAdapterCompatibleStandardWallet = StandardWalletWithFeatures<\n    StandardConnectFeature &\n        StandardEventsFeature &\n        (SolanaSignAndSendTransactionFeature | SolanaSignTransactionFeature) &\n        (StandardDisconnectFeature | SolanaSignMessageFeature | SolanaSignInFeature | object)\n>;\n\nexport interface StandardWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    wallet: WalletAdapterCompatibleStandardWallet;\n    standard: true;\n}\n\nexport type StandardWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    StandardWalletAdapterProps<Name>;\n\nexport function isWalletAdapterCompatibleStandardWallet(\n    wallet: StandardWallet\n): wallet is WalletAdapterCompatibleStandardWallet {\n    return (\n        StandardConnect in wallet.features &&\n        StandardEvents in wallet.features &&\n        (SolanaSignAndSendTransaction in wallet.features || SolanaSignTransaction in wallet.features)\n    );\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EACH,4BAA4B,EAI5B,qBAAqB,GAExB,MAAM,kCAAkC,CAAC;;AAE1C,OAAO,EACH,eAAe,EAGf,cAAc,GAEjB,MAAM,2BAA2B,CAAC;;;AAkB7B,SAAU,uCAAuC,CACnD,MAAsB;IAEtB,OAAO,AACH,+LAAe,IAAI,MAAM,CAAC,QAAQ,IAClC,6LAAc,IAAI,MAAM,CAAC,QAAQ,IACjC,CAAC,qOAA4B,IAAI,MAAM,CAAC,QAAQ,IAAI,uNAAqB,IAAI,MAAM,CAAC,QAAQ,CAAC,CAChG,CAAC;AACN,CAAC"}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-adapter-base/src/errors.ts"],"sourcesContent":["export class WalletError extends Error {\n    error: any;\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message?: string, error?: any) {\n        super(message);\n        this.error = error;\n    }\n}\n\nexport class WalletNotReadyError extends WalletError {\n    name = 'WalletNotReadyError';\n}\n\nexport class WalletLoadError extends WalletError {\n    name = 'WalletLoadError';\n}\n\nexport class WalletConfigError extends WalletError {\n    name = 'WalletConfigError';\n}\n\nexport class WalletConnectionError extends WalletError {\n    name = 'WalletConnectionError';\n}\n\nexport class WalletDisconnectedError extends WalletError {\n    name = 'WalletDisconnectedError';\n}\n\nexport class WalletDisconnectionError extends WalletError {\n    name = 'WalletDisconnectionError';\n}\n\nexport class WalletAccountError extends WalletError {\n    name = 'WalletAccountError';\n}\n\nexport class WalletPublicKeyError extends WalletError {\n    name = 'WalletPublicKeyError';\n}\n\nexport class WalletKeypairError extends WalletError {\n    name = 'WalletKeypairError';\n}\n\nexport class WalletNotConnectedError extends WalletError {\n    name = 'WalletNotConnectedError';\n}\n\nexport class WalletSendTransactionError extends WalletError {\n    name = 'WalletSendTransactionError';\n}\n\nexport class WalletSignTransactionError extends WalletError {\n    name = 'WalletSignTransactionError';\n}\n\nexport class WalletSignMessageError extends WalletError {\n    name = 'WalletSignMessageError';\n}\n\nexport class WalletSignInError extends WalletError {\n    name = 'WalletSignInError';\n}\n\nexport class WalletTimeoutError extends WalletError {\n    name = 'WalletTimeoutError';\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n    name = 'WalletWindowBlockedError';\n}\n\nexport class WalletWindowClosedError extends WalletError {\n    name = 'WalletWindowClosedError';\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAM,MAAO,WAAY,SAAQ,KAAK;IAGlC,6EAA6E;IAC7E,YAAY,OAAgB,EAAE,KAAW,CAAA;QACrC,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;CACJ;AAEK,MAAO,mBAAoB,SAAQ,WAAW;IAApD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,qBAAqB,CAAC;IACjC,CAAC;CAAA;AAEK,MAAO,eAAgB,SAAQ,WAAW;IAAhD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,iBAAiB,CAAC;IAC7B,CAAC;CAAA;AAEK,MAAO,iBAAkB,SAAQ,WAAW;IAAlD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,mBAAmB,CAAC;IAC/B,CAAC;CAAA;AAEK,MAAO,qBAAsB,SAAQ,WAAW;IAAtD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,uBAAuB,CAAC;IACnC,CAAC;CAAA;AAEK,MAAO,uBAAwB,SAAQ,WAAW;IAAxD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,yBAAyB,CAAC;IACrC,CAAC;CAAA;AAEK,MAAO,wBAAyB,SAAQ,WAAW;IAAzD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,0BAA0B,CAAC;IACtC,CAAC;CAAA;AAEK,MAAO,kBAAmB,SAAQ,WAAW;IAAnD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,oBAAoB,CAAC;IAChC,CAAC;CAAA;AAEK,MAAO,oBAAqB,SAAQ,WAAW;IAArD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,sBAAsB,CAAC;IAClC,CAAC;CAAA;AAEK,MAAO,kBAAmB,SAAQ,WAAW;IAAnD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,oBAAoB,CAAC;IAChC,CAAC;CAAA;AAEK,MAAO,uBAAwB,SAAQ,WAAW;IAAxD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,yBAAyB,CAAC;IACrC,CAAC;CAAA;AAEK,MAAO,0BAA2B,SAAQ,WAAW;IAA3D,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,4BAA4B,CAAC;IACxC,CAAC;CAAA;AAEK,MAAO,0BAA2B,SAAQ,WAAW;IAA3D,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,4BAA4B,CAAC;IACxC,CAAC;CAAA;AAEK,MAAO,sBAAuB,SAAQ,WAAW;IAAvD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,wBAAwB,CAAC;IACpC,CAAC;CAAA;AAEK,MAAO,iBAAkB,SAAQ,WAAW;IAAlD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,mBAAmB,CAAC;IAC/B,CAAC;CAAA;AAEK,MAAO,kBAAmB,SAAQ,WAAW;IAAnD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,oBAAoB,CAAC;IAChC,CAAC;CAAA;AAEK,MAAO,wBAAyB,SAAQ,WAAW;IAAzD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,0BAA0B,CAAC;IACtC,CAAC;CAAA;AAEK,MAAO,uBAAwB,SAAQ,WAAW;IAAxD,aAAA;;QACI,IAAA,CAAA,IAAI,GAAG,yBAAyB,CAAC;IACrC,CAAC;CAAA"}},
    {"offset": {"line": 4516, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/base.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/base.ts"],"sourcesContent":["import { Layout } from '@solana/buffer-layout';\n\nexport interface EncodeDecode<T> {\n    decode(buffer: Buffer, offset?: number): T;\n    encode(src: T, buffer: Buffer, offset?: number): number;\n}\n\nexport const encodeDecode = <T>(layout: Layout<T>): EncodeDecode<T> => {\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return { decode, encode };\n};\n"],"names":[],"mappings":";;;;AAOO,MAAM,YAAY,GAAG,CAAI,MAAiB,EAAmB,EAAE;IAClE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1C,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1C,OAAO;QAAE,MAAM;QAAE,MAAM;IAAA,CAAE,CAAC;AAC9B,CAAC,CAAC"}},
    {"offset": {"line": 4532, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/bigint.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/bigint.ts"],"sourcesContent":["import { blob, Layout } from '@solana/buffer-layout';\nimport { toBigIntBE, toBigIntLE, toBufferBE, toBufferLE } from 'bigint-buffer';\nimport { encodeDecode } from './base';\n\nexport const bigInt =\n    (length: number) =>\n    (property?: string): Layout<bigint> => {\n        const layout = blob(length, property);\n        const { encode, decode } = encodeDecode(layout);\n\n        const bigIntLayout = layout as Layout<unknown> as Layout<bigint>;\n\n        bigIntLayout.decode = (buffer: Buffer, offset: number) => {\n            const src = decode(buffer, offset);\n            return toBigIntLE(Buffer.from(src));\n        };\n\n        bigIntLayout.encode = (bigInt: bigint, buffer: Buffer, offset: number) => {\n            const src = toBufferLE(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n\n        return bigIntLayout;\n    };\n\nexport const bigIntBE =\n    (length: number) =>\n    (property?: string): Layout<bigint> => {\n        const layout = blob(length, property);\n        const { encode, decode } = encodeDecode(layout);\n\n        const bigIntLayout = layout as Layout<unknown> as Layout<bigint>;\n\n        bigIntLayout.decode = (buffer: Buffer, offset: number) => {\n            const src = decode(buffer, offset);\n            return toBigIntBE(Buffer.from(src));\n        };\n\n        bigIntLayout.encode = (bigInt: bigint, buffer: Buffer, offset: number) => {\n            const src = toBufferBE(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n\n        return bigIntLayout;\n    };\n\nexport const u64 = bigInt(8);\n\nexport const u64be = bigIntBE(8);\n\nexport const u128 = bigInt(16);\n\nexport const u128be = bigIntBE(16);\n\nexport const u192 = bigInt(24);\n\nexport const u192be = bigIntBE(24);\n\nexport const u256 = bigInt(32);\n\nexport const u256be = bigIntBE(32);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAc8B;AAd9B,OAAO,EAAE,IAAI,EAAU,MAAM,uBAAuB,CAAC;AACrD,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC/E,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;;;;AAE/B,MAAM,MAAM,GACf,CAAC,MAAc,EAAE,CACjB,CADmB,AAClB,QAAiB,EAAkB,EAAE;QAClC,MAAM,MAAM,OAAG,wKAAI,EAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACtC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAG,+LAAY,EAAC,MAAM,CAAC,CAAC;QAEhD,MAAM,YAAY,GAAG,MAA2C,CAAC;QAEjE,YAAY,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,EAAE;YACrD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACnC,WAAO,oKAAU,0KAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACxC,CAAC,CAAC;QAEF,YAAY,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;YACrE,MAAM,GAAG,OAAG,oKAAU,EAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACvC,OAAO,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACvC,CAAC,CAAC;QAEF,OAAO,YAAY,CAAC;IACxB,CAAC,CAAC;AAEC,MAAM,QAAQ,GACjB,CAAC,MAAc,EAAE,CACjB,CADmB,AAClB,QAAiB,EAAkB,EAAE;QAClC,MAAM,MAAM,OAAG,wKAAI,EAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACtC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,mMAAY,EAAC,MAAM,CAAC,CAAC;QAEhD,MAAM,YAAY,GAAG,MAA2C,CAAC;QAEjE,YAAY,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,EAAE;YACrD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACnC,WAAO,oKAAU,EAAC,wKAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACxC,CAAC,CAAC;QAEF,YAAY,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;YACrE,MAAM,GAAG,OAAG,oKAAU,EAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACvC,OAAO,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;QACvC,CAAC,CAAC;QAEF,OAAO,YAAY,CAAC;IACxB,CAAC,CAAC;AAEC,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAEtB,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;AAE1B,MAAM,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAExB,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAE5B,MAAM,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAExB,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAE5B,MAAM,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAExB,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC"}},
    {"offset": {"line": 4601, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/decimal.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/decimal.ts"],"sourcesContent":["import { Layout } from '@solana/buffer-layout';\nimport BigNumber from 'bignumber.js';\nimport { encodeDecode } from './base';\nimport { u128 } from './bigint';\n\nexport const WAD = new BigNumber('1e+18');\n\nexport const decimal = (property?: string): Layout<BigNumber> => {\n    const layout = u128(property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const decimalLayout = layout as Layout<unknown> as Layout<BigNumber>;\n\n    decimalLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset).toString();\n        return new BigNumber(src).div(WAD);\n    };\n\n    decimalLayout.encode = (decimal: BigNumber, buffer: Buffer, offset: number) => {\n        const src = BigInt(decimal.times(WAD).integerValue().toString());\n        return encode(src, buffer, offset);\n    };\n\n    return decimalLayout;\n};\n"],"names":[],"mappings":";;;;;;AACA,OAAO,SAAS,MAAM,cAAc,CAAC;AACrC,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,EAAE,IAAI,EAAE,MAAM,UAAU,CAAC;;;;AAEzB,MAAM,GAAG,GAAG,IAAI,2JAAS,CAAC,OAAO,CAAC,CAAC;AAEnC,MAAM,OAAO,GAAG,CAAC,QAAiB,EAAqB,EAAE;IAC5D,MAAM,MAAM,OAAG,yLAAI,EAAC,QAAQ,CAAC,CAAC;IAC9B,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAG,+LAAY,EAAC,MAAM,CAAC,CAAC;IAEhD,MAAM,aAAa,GAAG,MAA8C,CAAC;IAErE,aAAa,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,EAAE;QACtD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC9C,OAAO,IAAI,2JAAS,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC,CAAC,CAAC;IAEF,aAAa,CAAC,MAAM,GAAG,CAAC,OAAkB,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;QAC1E,MAAM,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACvC,CAAC,CAAC;IAEF,OAAO,aAAa,CAAC;AACzB,CAAC,CAAC"}},
    {"offset": {"line": 4632, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/native.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/native.ts"],"sourcesContent":["import { Layout, u8 } from '@solana/buffer-layout';\nimport { encodeDecode } from './base';\n\nexport const bool = (property?: string): Layout<boolean> => {\n    const layout = u8(property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const boolLayout = layout as Layout<unknown> as Layout<boolean>;\n\n    boolLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset);\n        return !!src;\n    };\n\n    boolLayout.encode = (bool: boolean, buffer: Buffer, offset: number) => {\n        const src = Number(bool);\n        return encode(src, buffer, offset);\n    };\n\n    return boolLayout;\n};\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAU,EAAE,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;;;AAE/B,MAAM,IAAI,GAAG,CAAC,QAAiB,EAAmB,EAAE;IACvD,MAAM,MAAM,OAAG,sKAAE,EAAC,QAAQ,CAAC,CAAC;IAC5B,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAG,+LAAY,EAAC,MAAM,CAAC,CAAC;IAEhD,MAAM,UAAU,GAAG,MAA4C,CAAC;IAEhE,UAAU,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,EAAE;QACnD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACnC,OAAO,CAAC,CAAC,GAAG,CAAC;IACjB,CAAC,CAAC;IAEF,UAAU,CAAC,MAAM,GAAG,CAAC,IAAa,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;QAClE,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACvC,CAAC,CAAC;IAEF,OAAO,UAAU,CAAC;AACtB,CAAC,CAAC"}},
    {"offset": {"line": 4658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/web3.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/web3.ts"],"sourcesContent":["import { blob, Layout } from '@solana/buffer-layout';\nimport { PublicKey } from '@solana/web3.js';\nimport { encodeDecode } from './base';\n\nexport const publicKey = (property?: string): Layout<PublicKey> => {\n    const layout = blob(32, property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const publicKeyLayout = layout as Layout<unknown> as Layout<PublicKey>;\n\n    publicKeyLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset);\n        return new PublicKey(src);\n    };\n\n    publicKeyLayout.encode = (publicKey: PublicKey, buffer: Buffer, offset: number) => {\n        const src = publicKey.toBuffer();\n        return encode(src, buffer, offset);\n    };\n\n    return publicKeyLayout;\n};\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,IAAI,EAAU,MAAM,uBAAuB,CAAC;AACrD,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAC5C,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;;;;AAE/B,MAAM,SAAS,GAAG,CAAC,QAAiB,EAAqB,EAAE;IAC9D,MAAM,MAAM,OAAG,wKAAI,EAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAClC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAG,+LAAY,EAAC,MAAM,CAAC,CAAC;IAEhD,MAAM,eAAe,GAAG,MAA8C,CAAC;IAEvE,eAAe,CAAC,MAAM,GAAG,CAAC,MAAc,EAAE,MAAc,EAAE,EAAE;QACxD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACnC,OAAO,IAAI,wLAAS,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC,CAAC;IAEF,eAAe,CAAC,MAAM,GAAG,CAAC,SAAoB,EAAE,MAAc,EAAE,MAAc,EAAE,EAAE;QAC9E,MAAM,GAAG,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;QACjC,OAAO,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACvC,CAAC,CAAC;IAEF,OAAO,eAAe,CAAC;AAC3B,CAAC,CAAC"}},
    {"offset": {"line": 4686, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/buffer-layout-utils/lib/esm/index.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/buffer-layout-utils/src/index.ts"],"sourcesContent":["export * from './base';\nexport * from './bigint';\nexport * from './decimal';\nexport * from './native';\nexport * from './web3';\n"],"names":[],"mappings":";AAAA,cAAc,QAAQ,CAAC;AACvB,cAAc,UAAU,CAAC;AACzB,cAAc,WAAW,CAAC;AAC1B,cAAc,UAAU,CAAC;AACzB,cAAc,QAAQ,CAAC"}},
    {"offset": {"line": 4701, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/dist/index.browser.mjs","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/assertions.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/utils.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/array.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/bit-array.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/boolean.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/bytes.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-strings/src/base16.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/constant.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/tuple.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/union.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/discriminated-union.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/enum-helpers.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/enum.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/hidden-prefix.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/hidden-suffix.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/map.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/unit.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/nullable.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/set.ts","file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/node_modules/%40solana/codecs-data-structures/src/struct.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n *  i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter(v => typeof v === 'number') as number[]),\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n"],"names":["newOffset","createEncoder","createDecoder","combineCodec","SolanaError","getEncodedSize","isFixedSize","getU8Encoder","transformEncoder","getU8Decoder","transformDecoder","containsBytes"],"mappings":"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"}},
    {"offset": {"line": 5552, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/spl-token-group/lib/esm/state/tokenGroup.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/src/state/tokenGroup.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['size', getU64Codec()],\n    ['maxSize', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n\nexport interface TokenGroup {\n    /** The authority that can sign to update the group */\n    updateAuthority?: PublicKey;\n    /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint */\n    mint: PublicKey;\n    /** The current number of group members */\n    size: bigint;\n    /** The maximum number of group members */\n    maxSize: bigint;\n}\n\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group: TokenGroup): ReadonlyUint8Array {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\n    return tokenGroupCodec.encode({\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: group.mint.toBuffer(),\n        size: group.size,\n        maxSize: group.maxSize,\n    });\n}\n\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroup {\n    const data = tokenGroupCodec.decode(buffer);\n\n    return isNonePubkey(data.updateAuthority)\n        ? {\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          }\n        : {\n              updateAuthority: new PublicKey(data.updateAuthority),\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          };\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;;;AAE5C,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,cAAc,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;;;AAE1F,MAAM,eAAe,OAAG,+PAAc,EAAC;IACnC;QAAC,iBAAiB;YAAE,+OAAY,MAAC,8PAAa,EAAE,GAAE,EAAE,CAAC;KAAC;IACtD;QAAC,MAAM;YAAE,+OAAY,MAAC,8PAAa,EAAE,GAAE,EAAE,CAAC;KAAC;IAC3C;QAAC,MAAM;YAAE,iPAAW,EAAE;KAAC;IACvB;QAAC,SAAS;YAAE,iPAAW,EAAE;KAAC;CAC7B,CAAC,CAAC;AAEI,MAAM,gBAAgB,GAAG,eAAe,CAAC,SAAS,CAAC;AAa1D,4CAA4C;AAC5C,SAAS,YAAY,CAAC,MAA0B;IAC5C,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACrC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACjB,CAAC;IACL,CAAC;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAGK,SAAU,cAAc,CAAC,KAAiB;IAC5C,8EAA8E;IAC9E,MAAM,eAAe,GAAG,KAAK,CAAC,eAAe,IAAI,wLAAS,CAAC,OAAO,CAAC;IACnE,OAAO,eAAe,CAAC,MAAM,CAAC;QAC1B,eAAe,EAAE,eAAe,CAAC,QAAQ,EAAE;QAC3C,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE;QAC3B,IAAI,EAAE,KAAK,CAAC,IAAI;QAChB,OAAO,EAAE,KAAK,CAAC,OAAO;KACzB,CAAC,CAAC;AACP,CAAC;AAGK,SAAU,gBAAgB,CAAC,MAAgD;IAC7E,MAAM,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAE5C,OAAO,YAAY,CAAC,IAAI,CAAC,eAAe,CAAC,GACnC;QACI,IAAI,EAAE,IAAI,wLAAS,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,OAAO,EAAE,IAAI,CAAC,OAAO;KACxB,GACD;QACI,eAAe,EAAE,IAAI,wLAAS,CAAC,IAAI,CAAC,eAAe,CAAC;QACpD,IAAI,EAAE,IAAI,wLAAS,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,OAAO,EAAE,IAAI,CAAC,OAAO;KACxB,CAAC;AACZ,CAAC"}},
    {"offset": {"line": 5621, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/spl-token-group/lib/esm/state/tokenGroupMember.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/spl-token-group/src/state/tokenGroupMember.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupMemberCodec = getStructCodec([\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['group', fixCodecSize(getBytesCodec(), 32)],\n    ['memberNumber', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;\n\nexport interface TokenGroupMember {\n    /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint */\n    mint: PublicKey;\n    /** The pubkey of the `TokenGroup` */\n    group: PublicKey;\n    /** The member number */\n    memberNumber: bigint;\n}\n\n// Pack TokenGroupMember into byte slab\nexport function packTokenGroupMember(member: TokenGroupMember): ReadonlyUint8Array {\n    return tokenGroupMemberCodec.encode({\n        mint: member.mint.toBuffer(),\n        group: member.group.toBuffer(),\n        memberNumber: member.memberNumber,\n    });\n}\n\n// unpack byte slab into TokenGroupMember\nexport function unpackTokenGroupMember(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroupMember {\n    const data = tokenGroupMemberCodec.decode(buffer);\n    return {\n        mint: new PublicKey(data.mint),\n        group: new PublicKey(data.group),\n        memberNumber: data.memberNumber,\n    };\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;;;AAE5C,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,cAAc,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;;;AAE1F,MAAM,qBAAqB,OAAG,+PAAc,EAAC;IACzC;QAAC,MAAM;YAAE,+OAAY,MAAC,8PAAa,EAAE,GAAE,EAAE,CAAC;KAAC;IAC3C;QAAC,OAAO;YAAE,+OAAY,MAAC,8PAAa,EAAE,GAAE,EAAE,CAAC;KAAC;IAC5C;QAAC,cAAc;YAAE,iPAAW,EAAE;KAAC;CAClC,CAAC,CAAC;AAEI,MAAM,uBAAuB,GAAG,qBAAqB,CAAC,SAAS,CAAC;AAYjE,SAAU,oBAAoB,CAAC,MAAwB;IACzD,OAAO,qBAAqB,CAAC,MAAM,CAAC;QAChC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE;QAC5B,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE;QAC9B,YAAY,EAAE,MAAM,CAAC,YAAY;KACpC,CAAC,CAAC;AACP,CAAC;AAGK,SAAU,sBAAsB,CAAC,MAAgD;IACnF,MAAM,IAAI,GAAG,qBAAqB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAClD,OAAO;QACH,IAAI,EAAE,IAAI,wLAAS,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,KAAK,EAAE,IAAI,wLAAS,CAAC,IAAI,CAAC,KAAK,CAAC;QAChC,YAAY,EAAE,IAAI,CAAC,YAAY;KAClC,CAAC;AACN,CAAC"}},
    {"offset": {"line": 5669, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-standard-features/src/signAndSendTransaction.ts"],"sourcesContent":["import type { IdentifierString } from '@wallet-standard/base';\nimport type {\n    SolanaSignTransactionInput,\n    SolanaSignTransactionOptions,\n    SolanaTransactionCommitment,\n    SolanaTransactionVersion,\n} from './signTransaction.js';\n\n/** Name of the feature. */\nexport const SolanaSignAndSendTransaction = 'solana:signAndSendTransaction';\n\n/** TODO: docs */\nexport type SolanaSignAndSendTransactionFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignAndSendTransaction]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignAndSendTransactionVersion;\n\n        /** TODO: docs */\n        readonly supportedTransactionVersions: readonly SolanaTransactionVersion[];\n\n        /**\n         * Sign transactions using the account's secret key and send them to the chain.\n         *\n         * @param inputs Inputs for signing and sending transactions.\n         *\n         * @return Outputs of signing and sending transactions.\n         */\n        readonly signAndSendTransaction: SolanaSignAndSendTransactionMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignAndSendTransactionVersion = '1.0.0';\n\n/** TODO: docs */\nexport type SolanaSignAndSendTransactionMethod = (\n    ...inputs: readonly SolanaSignAndSendTransactionInput[]\n) => Promise<readonly SolanaSignAndSendTransactionOutput[]>;\n\n/** Input for signing and sending a transaction. */\nexport interface SolanaSignAndSendTransactionInput extends SolanaSignTransactionInput {\n    /** Chain to use. */\n    readonly chain: IdentifierString;\n\n    /** TODO: docs */\n    readonly options?: SolanaSignAndSendTransactionOptions;\n}\n\n/** Output of signing and sending a transaction. */\nexport interface SolanaSignAndSendTransactionOutput {\n    /** Transaction signature, as raw bytes. */\n    readonly signature: Uint8Array;\n}\n\n/** Options for signing and sending a transaction. */\nexport type SolanaSignAndSendTransactionOptions = SolanaSignTransactionOptions & {\n    /** Desired commitment level. If provided, confirm the transaction after sending. */\n    readonly commitment?: SolanaTransactionCommitment;\n\n    /** Disable transaction verification at the RPC. */\n    readonly skipPreflight?: boolean;\n\n    /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */\n    readonly maxRetries?: number;\n};\n"],"names":[],"mappings":"AAQA,yBAAA,EAA2B;;;;AACpB,MAAM,4BAA4B,GAAG,+BAA+B,CAAC"}},
    {"offset": {"line": 5678, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-standard-features/src/signTransaction.ts"],"sourcesContent":["import type { IdentifierString, WalletAccount } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const SolanaSignTransaction = 'solana:signTransaction';\n\n/** TODO: docs */\nexport type SolanaSignTransactionFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignTransaction]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignTransactionVersion;\n\n        /** TODO: docs */\n        readonly supportedTransactionVersions: readonly SolanaTransactionVersion[];\n\n        /**\n         * Sign transactions using the account's secret key.\n         *\n         * @param inputs Inputs for signing transactions.\n         *\n         * @return Outputs of signing transactions.\n         */\n        readonly signTransaction: SolanaSignTransactionMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignTransactionVersion = '1.0.0';\n\n/** TODO: docs */\nexport type SolanaTransactionVersion = 'legacy' | 0;\n\n/** TODO: docs */\nexport type SolanaSignTransactionMethod = (\n    ...inputs: readonly SolanaSignTransactionInput[]\n) => Promise<readonly SolanaSignTransactionOutput[]>;\n\n/** Input for signing a transaction. */\nexport interface SolanaSignTransactionInput {\n    /** Account to use. */\n    readonly account: WalletAccount;\n\n    /** Serialized transaction, as raw bytes. */\n    readonly transaction: Uint8Array;\n\n    /** Chain to use. */\n    readonly chain?: IdentifierString;\n\n    /** TODO: docs */\n    readonly options?: SolanaSignTransactionOptions;\n}\n\n/** Output of signing a transaction. */\nexport interface SolanaSignTransactionOutput {\n    /**\n     * Signed, serialized transaction, as raw bytes.\n     * Returning a transaction rather than signatures allows multisig wallets, program wallets, and other wallets that\n     * use meta-transactions to return a modified, signed transaction.\n     */\n    readonly signedTransaction: Uint8Array;\n}\n\n/** Options for signing a transaction. */\nexport type SolanaSignTransactionOptions = {\n    /** Preflight commitment level. */\n    readonly preflightCommitment?: SolanaTransactionCommitment;\n\n    /** The minimum slot that the request can be evaluated at. */\n    readonly minContextSlot?: number;\n};\n\n/** Commitment level for transactions. */\nexport type SolanaTransactionCommitment = 'processed' | 'confirmed' | 'finalized';\n"],"names":[],"mappings":"AAEA,yBAAA,EAA2B;;;;AACpB,MAAM,qBAAqB,GAAG,wBAAwB,CAAC"}},
    {"offset": {"line": 5687, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-standard-features/src/signMessage.ts"],"sourcesContent":["import type { WalletAccount } from '@wallet-standard/base';\n\n/** Name of the feature. */\nexport const SolanaSignMessage = 'solana:signMessage';\n\n/** TODO: docs */\nexport type SolanaSignMessageFeature = {\n    /** Name of the feature. */\n    readonly [SolanaSignMessage]: {\n        /** Version of the feature API. */\n        readonly version: SolanaSignMessageVersion;\n\n        /** Sign messages (arbitrary bytes) using the account's secret key. */\n        readonly signMessage: SolanaSignMessageMethod;\n    };\n};\n\n/** Version of the feature. */\nexport type SolanaSignMessageVersion = '1.1.0' | '1.0.0';\n\n/** TODO: docs */\nexport type SolanaSignMessageMethod = (\n    ...inputs: readonly SolanaSignMessageInput[]\n) => Promise<readonly SolanaSignMessageOutput[]>;\n\n/** Input for signing a message. */\nexport interface SolanaSignMessageInput {\n    /** Account to use. */\n    readonly account: WalletAccount;\n\n    /** Message to sign, as raw bytes. */\n    readonly message: Uint8Array;\n}\n\n/** Output of signing a message. */\nexport interface SolanaSignMessageOutput {\n    /**\n     * Message bytes that were signed.\n     * The wallet may prefix or otherwise modify the message before signing it.\n     */\n    readonly signedMessage: Uint8Array;\n\n    /**\n     * Message signature produced.\n     * If the signature type is provided, the signature must be Ed25519.\n     */\n    readonly signature: Uint8Array;\n\n    /**\n     * Optional type of the message signature produced.\n     * If not provided, the signature must be Ed25519.\n     */\n    readonly signatureType?: 'ed25519';\n}\n"],"names":[],"mappings":"AAEA,yBAAA,EAA2B;;;;AACpB,MAAM,iBAAiB,GAAG,oBAAoB,CAAC"}},
    {"offset": {"line": 5696, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/wallet-standard-util/lib/esm/commitment.js","sources":["file:///C:/Users/HP/Desktop/Code/sol2/node_modules/%40solana/wallet-standard-util/src/commitment.ts"],"sourcesContent":["import type { SolanaTransactionCommitment } from '@solana/wallet-standard-features';\n\n// Copied from @solana/web3.js\ntype Commitment = 'processed' | 'confirmed' | 'finalized' | 'recent' | 'single' | 'singleGossip' | 'root' | 'max';\n\n/**\n * TODO: docs\n */\nexport function getCommitment(commitment?: Commitment): SolanaTransactionCommitment | undefined {\n    switch (commitment) {\n        case 'processed':\n        case 'confirmed':\n        case 'finalized':\n        case undefined:\n            return commitment;\n        case 'recent':\n            return 'processed';\n        case 'single':\n        case 'singleGossip':\n            return 'confirmed';\n        case 'max':\n        case 'root':\n            return 'finalized';\n        default:\n            return undefined;\n    }\n}\n"],"names":[],"mappings":"AAKA;;GAEG;;;;AACG,SAAU,aAAa,CAAC,UAAuB;IACjD,OAAQ,UAAU,EAAE,CAAC;QACjB,KAAK,WAAW,CAAC;QACjB,KAAK,WAAW,CAAC;QACjB,KAAK,WAAW,CAAC;QACjB,KAAK,SAAS;YACV,OAAO,UAAU,CAAC;QACtB,KAAK,QAAQ;YACT,OAAO,WAAW,CAAC;QACvB,KAAK,QAAQ,CAAC;QACd,KAAK,cAAc;YACf,OAAO,WAAW,CAAC;QACvB,KAAK,KAAK,CAAC;QACX,KAAK,MAAM;YACP,OAAO,WAAW,CAAC;QACvB;YACI,OAAO,SAAS,CAAC;IACzB,CAAC;AACL,CAAC"}}]
}